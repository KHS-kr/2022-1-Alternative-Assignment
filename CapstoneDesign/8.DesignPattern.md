#### 사이버보안학과 201520930 김희승
# 옵저버 패턴

RxJava는 옵저버 패턴을 확장한 구조이다. [옵저버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4) 은
**GoF가 처음 제시한 디자인 패턴의 한가지**로 *관찰 대상 객체의 상태에 변화(값의 변경 등)가 발생하면 해당 객체를 관찰하는 객체가 변화에 따라 처리 작업을 하는 디자인 패턴*이다.

옵저버 패턴에서는 관찰 대상이 되는 `Subject`에 이를 관찰하는 `Observer`를 등록한다. 그리고 `Subject`의 상태가 변하면 등록된 모든 `Observer`에 변화가 발생한 사실을
통지한다. `Observer`는 `Subject`로부터 통지를 받은 후 변화에 따른 적절한 처리를 한다.

### 옵저버 패턴에서 사용하는 클래스

| 클래스              | 설명                                                                                                                    |
|------------------|-----------------------------------------------------------------------------------------------------------------------|
| Subject          | 관찰 대상을 나타내는 클래스<br/>이 클래스에 Observer를 추가하거나 삭제할 수 있으며 상태 변화가 발생했을 때에 통지 처리 기능이 있다.                                     |
| Observer         | 변화가 발생했을 때 이를 처리하는 메서드가 있는 인터페이스                                                                                      |
| ConcreteSubject  | Subject를 상속한 클래스<br/>실제 변화가 이 클래스에서 일어나며, 변화가 발생했을 때 Subject의 통지 처리 메서드인 notifyObservers를 호출해 등록된 Observer에 통지할 수 있다. |
| ConcreteObserver | Observer의 구현 클래스<br/>통지가 발생했을 때 처리할 내용을 구현                                                                            |

### Subject의 메서드

| 메서드                      | 설명                                                                   |
|--------------------------|----------------------------------------------------------------------|
| addObserver(Observer)    | 변화를 관찰하는 Observer 등록                                                 |
| deleteObserver(Observer) | 등록된 Observer를 리스트에서 삭제                                               |
| notifyObservers()        | 등록된 Observer들에게 변화가 발생했을 시에 통지<br/>(실제로는 등록된 Observer의 update메서드 호출) |

### Observer의 메서드

| 메서드    | 설명                                                                         |
|--------|----------------------------------------------------------------------------|
| update | 변화가 발생했다는 통지를 받으면 처리를 수행한다.<br/>실제 처리 내용은 Observer 인터페이스의 구현 클래스에 구현되어 있다. |

> 옵저버 패턴에서 가장 중요한 특징은 **관찰 대상인 `Subject`에 상태 변화가 발생했을 때 스스로 자신에게 변화가 발생했다고 `Observer`에게 통지한다**는 것이다.

> 또 다른 특징은 관찰 대상인 `Subject`와 `Observer`가 분리됐다는 점이다. `Subject`는 자신의 상태가 변경될 때 어떤 작업을 하는지 알 필요가 없고, 통지만 해주면 된다.

# 이터레이터 패턴

RxJava의 실제 구현은 이터레이터 패턴과 완전히 다른 구조를 가지고 있으나, 개념에는 많은 영향을 주었다. 이터레이터 패턴 또한 GoF가 처음 제시한 디자인 패턴의 한가지로, **데이터 집합체(aggregate)
에서 순서대로 데이터를 꺼내기 위한 패턴**이다.

이터레이터 패턴은 집합체에서 데이터를 꺼내는 `Iterator`를 생성하고, 이 `Iterator`로 데이터를 하나씩 순서대로 얻을 수 있게 한다. 이 때, 데이터 집합체가 어떤 형태로 데이터를 가지고
있는지는 `Iterator`를 사용하는 측에서는 알 필요가 없다. 단순히, 가져갈 데이터가 더 있는지를 판단하는 `hasNext`메서드를 호출해 데이터가 있다면 `next` 메서드를 사용해 데이터를 얻어 처리 작업을
반복하면 된다.

### 이터레이터 패턴에서 사용하는 클래스

| 클래스               | 설명                                 |
|-------------------|------------------------------------|
| Aggregate         | 데이터를 담고 있는 집합체를 나타내는 인터페이스         |
| Iterator          | 데이터를 순서대로 받을 수 있게 하는 인터페이스         |
| ConcreteAggregate | 실제 데이터를 넣어 두는 데이터 집합체를 구현한 클래스     |
| ConcreteIterator  | 실제로 데이터를 받을 수 있게 Iterator를 구현한 클래스 |

### Aggregate의 메서드

| 메서드      | 설명              |
|----------|-----------------|
| iterator | Iterator를 생성한다. |

### Iterator의 메서드

| 메서드     | 설명                                         |
|---------|--------------------------------------------|
| hasNext | true를 반환하면 next메서드로 받을 수 있는 데이터가 있음을 나타낸다. |

## 이터레이터 패턴 예제

```kotlin
fun main() {
    val list = listOf("a", "b", "C")
    val iterator = list.iterator()

    while (iterator.hasNext()) {
        val value = iterator.next()

        println(value)
    }
}
```

```text
a
b
c
```

우리가 일반적으로 사용하는 `list` 등 `Collection`에도 **이터레이터 패턴**이 적용되어 있다.

RxJava에서는 생산자 자체가 데이터 집합체이므로, 데이터를 순서대로 공급하는 역할도 한다. 단, 소비자가 데이터를 가져가는 형태(pull)가 아니라 ***소비자에게 데이터를 통지하는 형태(push)*** 이다. 
