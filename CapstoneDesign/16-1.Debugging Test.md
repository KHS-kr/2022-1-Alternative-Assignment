#### 사이버보안학과 201520930 김희승
# 디버깅과 테스트

리액티브 프로그래밍에서 생산자가 소비자에게 통지하는 데이터는 기본적으로 외부에서 접근할 수 없기 때문에 RxJava로 구현한 코드를 디버깅하거나 테스트 하는 것은 쉽지 않다. 따라서, 생산자가 처리를 시작한 후에
소비자가 완료나 에러 통지를 받을 때 까지 처리가 끝나야만 어떠한 데이터가 어떻게 바뀌었는지 외부에서 확인할 수 있다.

또한, 비동기 처리를 할 경우에는 여러 처리가 동시에 실행되므로 실행할 때마다 결과가 달라질 수 있다. 경우에 따라 `A -> B` 혹은, `B -> A` 처럼 순서가 바뀌어 완료될 수 있다. 순서가 보장되지 않는
상태에서 디버깅이나 테스트를 진행한다면, 실행할 때마다 결과가 바뀌거나 문제를 확인하기 어려울 수 있다.

RxJava는 디버깅이나 테스트를 쉽게 할 수 있는 여러 메서드와 클래스를 제공한다.

* `do`로 시작하는 메서드 : 통지 시점에 미리 지정한 처리를 수행하는 메서드. 통지 시에 로그를 출력하는 등의 처리를 할 수 있다.
* `blocking`으로 시작하는 메서드 : `Flowable`/`Observable`이 호출자의 스레드가 아닌 다른 스레드에서 처리를 하더라도 호출자의 스레드에서 그 결과를 받게 하는 메서드. 테스트 스레드에서
  결과를 받을 때 까지 기다렸다가 결괏값을 받으면 이를 기댓값과 비교할 수 있다.
* `TestSubscriber`/`TestObserver` : `Flowable`/`Observable`을 테스트할 때 생성하는 `Subscriber`/`Observer` 클래스. `assert` 메서드와 같이
  테스트 목적으로 사용할 수 있는 메서드를 제공한다.
* `TestScheduler` : 테스트할 때 실제로 실행 시간 경과를 기다리지 않고 이를 내부적으로 계산하여 예상되는 통지 데이터 결과를 받을 수 있도록 하는 테스트 용도의 스케줄러. RxJava에서 시간을
  다루는 처리를 할 때 기다릴 필요 없이 결과를 바로 받아 테스트할 수 있다.

이러한 테스트를 위한 메서드나 클래스를 사용하더라도 비동기 처리가 있다면 원하는 대로 동작하지 않을 경우가 있을 수 있음을 고려해야 한다. </br>
또한, 생산자와 소비자를 쉽게 분리할 수 있는지도 매우 중요하다. 특히, `subscribe` 메서드에 전달하는 인자를 익명 클래스로 직접 구현하면 해당 테스트 용도의 메서드나 클래스를 사용할 수 없다. 이처럼
테스트 용도의 메서드나 클래스를 사용하는 것은 구현 방식에도 영향을 미친다. </br>
`do`또는 `blocking`으로 시작하는 메서드는 비즈니스 로직의 일부로 사용하는 것도 가능하다. 하지만, 디버깅과 테스트 목적의 메서드이기 때문에 어떠한 부가 작용이 발생할지 파악이 어려워 위험성이 있다.
따라서 사용하지 않는 것이 좋다.